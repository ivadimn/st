
X Protocol — это информация, которой обмениваются клиент и сервер системы X Window. Это протокол, который позволяет X работать. Именно существование этого протокола для такого обмена информацией позволяет клиенту и серверу X Window быть подключенными к сети, а не на одном компьютере. Клиентская программа обменивается этими пакетами протокола с серверной программой, используя любое сетевое программное обеспечение, доступное на компьютерах, которые выполняют клиентские и серверные программы. Чем более общим является это сетевое программное обеспечение, тем более общим может быть распределение клиентских и серверных программ по сети. Если сетевое программное обеспечение взаимодействует через локальную сеть (LAN), то клиенты и серверы X Window,
используемые в любой конкретной программе X Window, должны находиться на компьютерах,
подключенных к этой локальной сети. Если сетевое программное обеспечение способно получать доступ к Интернету, то клиенты и серверы X Window могут быть распределены по Интернету.

Связь X Protocol и Xlib аналогична связи между языком компьютерной машины и языком ассемблера, а также наборами инструментов и языками компиляторов, как указано ниже:

Toolkits == compiler language
            l
Xlib == assembler language
            l
X Protocol == machine language

Эта компоновка показывает возрастающую сложность в продвижении от верхнего к нижнему слою вдоль
каждой ноги этого стека. Каждый слой воплощает уровень удаления от деталей реализации.

Знание X-протокола X Window аналогично знанию комбинации нулей и единиц, которые
управляют работой оборудования конкретного компьютера (его машинного языка). Это наиболее
сложно для понимания, но также приводит к наиболее полному пониманию способа, которым
должно быть выполнено требуемое выполнение. Xlib предоставляет средства получения определенной комбинации
нулей и единиц для создания определенной функции X Window, так же как язык ассемблера создает
комбинацию нулей и единиц, которая реализует набор инструкций конкретного компьютера. Так же как
определенная инструкция, заданная в программе на языке ассемблера, генерирует байты, которые представляют эту
соответствующую инструкцию по отношению к компьютерному оборудованию, так и определенная функция Xlib создает
байты, которые реализуют ее соответствие в X-протоколе. Наименьшая сложность связана с наборами инструментов, 
такими как GTK, Athena, Motif и т. д. Они соответствуют компилируемым языкам, таким как C,
Fortran, Ada и т. д. в том, что они обеспечивают высокий уровень абстракции вычислительного процесса. Однако,
как в случае с набором инструментов, так и в случае с компилируемым языком, программы, созданные в них, преобразуются
программным обеспечением в элементы самого низкого уровня их конкретной ветви этого стека.

Xlib — это язык C, связанный с X Protocol. Xlib используется в сочетании с программами,
написанными на языке программирования C. При написании программ на C функции Xlib используются
таким же образом, как и с встроенным ассемблером. Xlib — это библиотека функций.

Хотя можно создать пакет протокола X вручную, для практических целей программирования это не очень хорошая идея. Недостатки использования ручного подхода включают:
• нестандартный подход, усложняющий обслуживание программы
• большинство программистов не заинтересованы в протоколе и не понимают его на требуемом уровне

1.3 Проблемы программирования X Window

При программировании с помощью X Window необходимо учитывать следующее:

1. Все окна содержатся в корневом окне;
2. Подокно должно содержаться в своем родительском окне или быть обрезанным;
3. Родительское окно всегда имеет строку заголовка;
4. Меню, кнопки и диалоговые окна рассматриваются как окна;
5. Все измерения длины указаны в пикселях экрана;
6. Каждое окно имеет собственную систему координат

Экран дисплея сервера X Window является корневым окном. Каждое окно, созданное в X Window, содержится в нем. Сервер не пытается изменить размеры окна или изменить его положение, так как окно содержится в корневом окне. Если серверу будет предложено
показать окно, он сделает это, но части окна, выходящие за пределы корневого окна, будут обрезаны.

Все подокна должны отображаться в пределах окна, которое является его родительским. Примером такого подокна является меню. Если это подокно превышает экранные размеры своего родительского окна, то часть этого подокна, которая выходит за пределы, будет удалена менеджером экранов X Window.

Когда создается окно, которое создается с корневым окном в качестве его родителя, будет иметь заголовок.
Содержимое этого заголовка может быть явно назначено в программировании, которое настраивает это окно.

В X Window все является окном. Нет таких специальных сущностей, как меню, кнопки, диалоговые
окна, ползунки, подсветка или 3D-эффекты любого рода. Однако есть несколько исключений. Одним из них является
курсор, используемый для обозначения положения указателя мыши на экране. Кроме того, ни линия, ни символ в шрифте, ни значок не являются окном. Однако во всех этих исключительных случаях каждое из них должно быть нарисовано в на используемом экране. Таким образом, возможно, что внешний вид окна может измениться при просмотре на разных экранах.
Каждое окно имеет свою собственную систему координат. Начало этой системы координат находится в
верхнем левом углу окна. Координата x увеличивается слева направо. Координата y увеличивается сверху вниз окна. Отрицательных координат нет. Все координаты в пикселях экрана.
окне.

Размеры окон и их положение на экране всегда находятся в измерении пикселей экрана. Физический вид окна на экране определяется распределением пикселей на используемом экране. Таким образом, возможно, что внешний вид окна может измениться при просмотре
на разных экранах.

Каждое окно имеет свою собственную систему координат. Начало этой системы координат находится в
верхнем левом углу окна. Координата x увеличивается слева направо. Координата y увеличивается сверху вниз окна. Отрицательных координат нет. Все координаты в пикселях экрана.

2 Getting started.

Программирование в системе X Window сосредоточено на окне. В создании конечного отображаемого изображения может быть задействовано множество окон, а конечный эффект зависит от перекрытия, появления, исчезновения и соседства ряда таких окон и их содержимого. Поэтому освоение программирования в X Window начинается с освоения программирования одного окна. Такое
программирование состоит из четырех основных частей:

1. создание окна;
2. создание этого окна видимым;
3. рисование в этом окне; и
4. обработка ввода в этом окне.

Каждая из этих частей будет обсуждаться и демонстрироваться на примерах в этой и следующих главах.
Каждая из этих частей имеет ряд подчастей. Сложность и, как следствие, мощность и гибкость программирования в X Window являются результатом важных взаимодействий между этими основными частями и их подчастями.
Система X Window определяется своим протоколом. Этот протокол представляет собой серию сообщений, которые
передаются между клиентом и сервером. Клиент — это программа, например, те, которые будут
написаны в этой книге, которые содержат вызовы функций Xlib. Эти вызовы функций генерируют
сообщения протокола, которые отправляются на сервер. Сервер — это часть кода X Window, которая выполняет
запросы, отправленные ему через сообщения протокола. Так, клиентская программа, например, настраивает детали
окна и запрашивает его появление на дисплее. Сервер фактически создает окно на дисплее.

Вызовы функций Xlib являются частью библиотеки, которая предоставляет программисту доступ к
сообщениям протокола. Таким образом, их можно рассматривать как язык ассемблера X Window System. Как и в программировании в целом, существуют языки более высокого порядка. В контексте X Window System они известны как наборы инструментов. Использование наборов инструментов отдаляет программиста от многих (но не всех)
деталей, связанных с программированием протокола X Window System. Во многих случаях это делается
путем предоставления политики, которая становится характеристикой инструментария, для связывания базовых
запросов протокола. Но, как указано в ? (страница xxii), целью создания X Window System было
предоставить механизм, а не политику. В результате Xlib предоставляет наиболее практичные средства исследования
того, чего можно достичь с помощью X Window System. Цена этого понимания заключается в том, что от программиста требуется больше. Исходные программы становятся длиннее, чем те, которые используют инструментарии, и
вероятность упущений увеличивается. Средство помощи программисту в использовании Xlib предоставляется
далее с помощью использования полных, работающих примеров.
В этой главе рассматривается создание окна и его отображение на экране X Window.

2.1 Основные шаги программирования Xlib

Подход к программированию Xlib, предлагаемый здесь, заключается в выполнении ряда шагов. В некоторых случаях
все эти шаги не требуются, как будет показано в примерах, которые приведены ниже в этой книге. В этом
шаговом процессе нет ничего нового. ? предлагает использовать восемь таких шагов, а именно:

1. открыть соединение с сервером с помощью XOpenDisplay
2. создать окно верхнего уровня с помощью XCreateWindow
3. установить стандартные свойства для окна верхнего уровня, включая подсказки для оконного менеджера
4. создать ресурсы окна, такие как графические контексты
5. создать любые другие необходимые окна
6. выбрать нужные события для этих окон
7. сопоставить окна
8. войти в цикл событий

для создания программы Xlib. Затем он приводит код интересной и практичной программы Xlib,
которая, к сожалению, не использует функцию XCreateWindow(), а вместо этого использует XCreateSimpleWindow()
Но этот код помещается на одной печатной странице. Однако этот код необходимо изменить и добавить дополнительные
шаги для выполнения требований текущего выпуска X Window 11 7 по сравнению с выпуском 2, используемым в
этой статье. Эти изменения касаются администрирования и инициализации приложения X Window;
вызовы для создания действия, содержащегося в программе, не изменились.

Девять шагов для создания прикладной программы Xlib с использованием Xlib:

1. открыть соединение с сервером
2. создать окно верхнего уровня
3. дать подсказки диспетчеру окон
4. установить ресурсы окна
5. создать все остальные необходимые окна
6. выбрать события для каждого окна
7. сопоставить окна
8. войти в цикл событий
9. очистить перед выходом

2.2 Создание одного окна

Одной из трудностей программирования X Window является то, что нужно многое сделать, прежде чем что-либо появится на экране дисплея. Если все эти шаги выполнены неправильно, ничего не появится, даже если это почти правильно. Здесь используется простой пример для демонстрации шагов программирования, которые необходимы для получения видимого результата из X Window.

Первый пример тривиален, но он демонстрирует основные процессы, которым необходимо следовать при программировании с использованием Xlib. Пример создает пустое окно заданного размера в цвете по умолчанию на экране дисплея по умолчанию. Рисунок 2.1 показывает полученный вывод. Хотя этот пример тривиален по своему результату, он четко показывает шаги, необходимые для создания функционирующей программы X Window с использованием Xlib. Будет видно, что такие шаги сами по себе не являются тривиальными. Поскольку эти шаги
повторяются со всеми программами Xlib в этой книге, сначала будет представлен шаблон для написания программ Xlib, прежде чем применять его к конкретному примеру. В результате эта глава важна, поскольку она задает тон подходу, используемому в этой книге.

2.2.1 Открытm соединение с сервером

Как описано на странице 126 из ?, каждое клиентское приложение X содержит часть Xlib, встроенную в него во время компиляции. Код приложения вызывает этот код для преобразования вызовов функций Xlib, содержащихся в прикладной программе, в запросы протокола X для части управления этого компонента Xlib для отправки по сети на сервер. Эта часть управления буферизует запросы протокола X, чтобы максимально эффективно использовать сеть между этим клиентом и требуемым сервером. Этот компонент Xlib
также предоставляет структуры данных, которые локально представляют каждый удаленный сервер, к которому клиенту требуется доступ. Затем приложение может получить доступ к этому локальному представлению, чтобы получить информацию о сервере,
не отправляя запросы по сети на сам сервер. Он также буферизует события X, относящиеся к этому приложению, полученные от всех серверов. Каждое приложение X содержит отдельную копию описания каждого сервера, к которому оно подключено.
Структуры Display, Screen и Visual устанавливаются в части Xlib в коде клиента X11,
когда выполняется подключение к серверу. Структура Visual содержит информацию о том, как
представлены цвета для экрана. Структура Screen содержит информацию как о физической
природе (такой как его высота, ширина, черно-белые пиксельные шаблоны, биты на пиксель (глубина) и т. д.), так и о том, как
этот физический экран попадает в модель X11 (например, его корневое окно, цветовая карта по умолчанию, GC
для корня и т. д.). Структура Display содержит информацию, касающуюся формирования пакетов протокола X, которые должны передаваться и приниматься между клиентом и сервером. 
Примеры таких информация, как максимальное количество 32-битных слов в запросе, порядок байтов экрана, используемая строка host:display, номер экрана по умолчанию и количество экранов на сервере. Эти три структуры определены в заголовочном файле Xlib.h.
К членам структур Display, Screen и Visual не осуществляется прямой доступ кодами приложений. В случаях, когда значения по умолчанию, установленные в этих структурах, требуются кодами приложений,
X11 предоставляет одиннадцать функций XDefault* для доступа к таким значениям. Эти функции также
доступны как макросы Default*.
Чтобы использовать X Window, клиентская программа сначала запрашивает соединение с сервером. Это установит в клиентском компоненте Xlib представление сервера в виде структуры Display.
Для этого используется функция XOpenDisplay(). Она возвращает указатель на приложение структуры Display, хранящейся в компоненте Xlib клиентской программы. Эта структура описывает подробную информацию о конфигурации сервера. XOpenDisplay() реализуется с помощью запроса CreateGC protocol (STRANGE). Информация, содержащаяся в этих структурах, доступна клиентскому приложению
через макросы Default.

2.2.2 Окно верхнего уровня

Приложение X Window состоит только из окон. X Window предоставляет только один тип окна, но его можно оборудовать по-разному для разных целей. В других системах управления окнами нет специализированных кнопок, полос прокрутки, полей ввода текста и т. д. Каждый из этих элементов может быть создан из окна или комбинации более чем одного окна в X Window. X Window предоставляет
свободу комбинирования в рамках ограничения иерархических отношений между окнами. Таким образом, X Window, как говорят, предоставляет механизм без навязывания политики. Именно эта общность делает X Window одновременно мощным и сложным для программиста, поскольку доступно большое количество опций.
Все окна в X Window образуют иерархию. Родительское окно может содержать подокна, а эти подокна могут содержать подокна и т. д. Эти отношения образуют иерархию, в которой родитель является корнем иерархического дерева. Поверхность экрана, занимаемая такими подокнами, должна попадать
внутрь области поверхности, определенной для ее родителя. Эти родители могут быть результатом независимых или взаимозависимых запущенных программ, и их распределение области поверхности экрана может быть разделено или перекрываться, перекрываться полностью или частично. В соответствии с иерархией окон, эти родительские окна
сами являются подокнами главного окна, называемого корневым окном. Это корневое окно управляется
менеджером окон.
Когда окно инициализируется, ему необходимо указать своего родителя. В случае окна верхнего уровня
этот родитель является корневым окном. Как описано в Разделе 2.2.1, первое действие, которое выполняет клиентская программа,
заключается в использовании вызова XOpenDisplay() для создания структур данных Display, Screen и Visual в части Xlib исполняемого кода клиента. Эти структуры поддерживают иерархическую структуру окна,
которую клиентская программа затем строит и впоследствии использует.
Для создания окна доступны два вызова Xlib; XCreateSimpleWindow() и XCreateWindow(). Вызов XCreateWindow() имеет большую общность и используется здесь.
Допустим, код на рисунке 2.2 содержится в файле basic.c. В системе Linux, использующей gcc
версии 4.1.1 и X11 версии 7.1.0, этот код компилируется и связывается с командой оболочки:

gcc -o basic -I /usr/include/X11 -L /usr/X11R6/lib -lX11 basic.c

Полученный исполняемый файл basic затем запускается с помощью команды оболочки:

./basic &

#include <X11/Xlib.h>
#include <X11/Xutil.h>

int main(int argc, char* argv[])
{
    Display *mydisplay;
    XSetWindowAttributes myat;
    Window mywindow;
    XSizeHints wmsize;
    XWMHints wmhints;
    XTextProperty windowName, iconName;
    XEvent myevent;
    char *window_name = "Basic";
    char *icon_name = "Ba";
    int screen_num, done;
    unsigned long valuemask;

    /* 1. открыть соединенте с сервером X window */
    mydisplay = XOpenDisplay("");

    /* 2. создать верхнеуровневое (root) окно */
    screen_num = DefaultScreen(mydisplay);
    myat.background_pixel = WhitePixel(mydisplay, screen_num);
    myat.border_pixel = BlackPixel(mydisplay, screen_num);
    myat.event_mask = ButtonPressMask;
    valuemask = CWBackPixel | CWBorderPixel | CWEventMask;
    mywindow = XCreateWindow(mydisplay, RootWindow(mydisplay, screen_num), 
                            200, 200, 600, 400, 2,
                            DefaultDepth(mydisplay, screen_num), InputOutput, 
                            DefaultVisual(mydisplay, screen_num), 
                            valuemask, &myat);

    /* 3. дайте подсказки диспетчеру окон */

    wmsize.flags = USPosition | USSize;
    XSetWMNormalHints(mydisplay, mywindow, &wmsize);
    wmhints.initial_state = NormalState;
    wmhints.flags = StateHint;
    XSetWMHints(mydisplay, mywindow, &wmhints);
    XStringListToTextProperty(&window_name, 1, &windowName);
    XSetWMName(mydisplay, mywindow, &windowName);
    XStringListToTextProperty(&icon_name, 1, &iconName);
    XSetWMIconName(mydisplay, mywindow, &iconName);

    /*     4. Установить ресурсы окон  */
    /*  5. Создать все остальные необходимые окна  */
    /*  6. Выбрать события для каждого окна  */
    /*  7. Сопоставить окна  */

    XMapWindow(mydisplay, mywindow);

    done = 0;
    while (done == 0)
    {
        XNextEvent(mydisplay, &myevent);
        switch (myevent.type)
        {
        case ButtonPress:
            break;
        }
    }
    XUnmapWindow(mydisplay, mywindow);
    XDestroyWindow(mydisplay, mywindow);
    XCloseDisplay(mydisplay);   
    return 0;

}

Что касается примера X Window на рисунке 2.2, следует отметить следующее:

• Это, возможно, самый простой пример из возможных;
• В примере нет способа завершить выполнение. В системе Unix это можно сделать с помощью ps из оболочки для поиска идентификатора процесса исполняемого кода и использования этого идентификатора в команде kill из оболочки для завершения этого процесса.
• 9 шагов показаны как комментарии, но используются только 5;
• Из-за способа завершения программы шаг 9 не является необходимым,
потому что он никогда не будет выполнен;
• Использование максимального количества значений по умолчанию было использовано для сокращения размера примера
до минимума;
• Цикл событий шага 8 необходим, иначе на экране сервера не появится окно.
Попробуйте удалить этот цикл, чтобы проверить это утверждение. Цикл требуется для обеспечения обработки событий, которая необходима для функционирования Xlib.
• Важно. Та же переменная типа XEvent должна использоваться в вызове функции XNextEvent() и во всей последующей обработке этого события. В этом примере это происходит только в операторе switch.

На рисунке 2.1 показано, что появляется на экране при выполнении программы на рисунке 2.2. Этот
пример только создает окно и размещает его на экране. Это окно пустое. Примечание: при
создании окна графический контекст (GC) не задействован (см. далее). Графический контекст задействован только при рисовании в этом окне — графический контекст связан с операциями рисования.
На рисунке 2.1 показаны некоторые дополнения. К ним относятся оформление окна и окружающий черно-белый узор из точек корневого окна, используемого на компьютере, с которого был сделан снимок экрана. Они будут отображаться на всех снимках экрана на следующих страницах. Они являются свойством диспетчера окон X11, что выходит за рамки данной текущей работы.

Примечание: большинство приложений X Window начинаются как каркас, прикрепленный к указателю на экране.
При нажатии кнопки мыши диспетчер окон рисует окно, содержащееся в коде, например, как на рисунке 2.1. Этого не происходит, когда код рисунка 2.2 или любая другая программа, содержащаяся в этой работе. Вместо этого начальное окно рисуется на экране в позиции, назначенной в вызове XCreateWindow(). Это изменение в поведении связано с XSetWMNormalHints() вызов. Этот вызов предоставляет диспетчеру окон на компьютере, выполняющем код, дополнительную информацию, без которой пользователю предлагается предоставить ее с помощью указателя мыши.

2.2.3 Упражнения

1. Измените код на рисунке 2.2 так, чтобы была реализована проверка ошибок.
2. Какое простое изменение можно внести в код на рисунке 2.2, чтобы щелчок мышью
в любом месте в пределах белого окна приводил к завершению программы?
3. Какое простое изменение можно внести в код на рисунке 2.2, чтобы щелчок мышью
внутри пределов белого окна вызывал звук колокольчика каждый раз при щелчке мышью?
4. Измените код на рисунке 2.2 так, чтобы белое окно окрасилось в желтый цвет.
5. Найдите выборку диспетчеров окон, в которых использование вызова XSetWMNormalHints() имеет указанный выше эффект, а в
том числе нет. Например, подсказки имеют эффект в twm, но не в dwm. Почему это происходит и как это влияет на использование кода, реализованного в X Window?


2.3 Наименьшая программа Xlib для создания окна


Код на рисунке 2.2 включает все части, рекомендуемые для включения при написании программы Xlib. Этот подход будет использоваться во всех последующих примерах. Но он также реализует политику в предоставлении поддержки базового оконного менеджера. Однако X Window был разработан для предоставления механизма, а не политики. Итак, какой наименьший объем кода Xlib требуется для создания
окна на экране? Код на рисунке 2.3 является ответом.
При выполнении код на рисунке 2.3 создает окно на экране, такое же, как показано
на рисунке 2.1. В коде ряд параметров остаются неуказанными, например, цвет
границы окна. Значения по умолчанию для этих параметров предоставляются либо X-сервером, либо
используемым оконным менеджером. Поскольку код не предоставляет заголовок, окно имеет заголовок Untitled
оконным менеджером. Менеджеру окон не даются подсказки, помогающие ему отобразить
окно, но менеджер окон выполняет свою работу. В программе используются четыре основных вызова Xlib с четырьмя вспомогательными вызовами. Хотя с окном не связаны никакие события, для появления окна требуется вызов Xlib XNextEvent(). Поскольку в переменной myevent не указаны никакие события, вызов XNextEvent() генерирует неопределенное ожидание. Без этого вызова на экране ничего не отображается.








