
X Protocol — это информация, которой обмениваются клиент и сервер системы X Window. Это протокол, который позволяет X работать. Именно существование этого протокола для такого обмена информацией позволяет клиенту и серверу X Window быть подключенными к сети, а не на одном компьютере. Клиентская программа обменивается этими пакетами протокола с серверной программой, используя любое сетевое программное обеспечение, доступное на компьютерах, которые выполняют клиентские и серверные программы. Чем более общим является это сетевое программное обеспечение, тем более общим может быть распределение клиентских и серверных программ по сети. Если сетевое программное обеспечение взаимодействует через локальную сеть (LAN), то клиенты и серверы X Window,
используемые в любой конкретной программе X Window, должны находиться на компьютерах,
подключенных к этой локальной сети. Если сетевое программное обеспечение способно получать доступ к Интернету, то клиенты и серверы X Window могут быть распределены по Интернету.

Связь X Protocol и Xlib аналогична связи между языком компьютерной машины и языком ассемблера, а также наборами инструментов и языками компиляторов, как указано ниже:

Toolkits == compiler language
            l
Xlib == assembler language
            l
X Protocol == machine language

Эта компоновка показывает возрастающую сложность в продвижении от верхнего к нижнему слою вдоль
каждой ноги этого стека. Каждый слой воплощает уровень удаления от деталей реализации.

Знание X-протокола X Window аналогично знанию комбинации нулей и единиц, которые
управляют работой оборудования конкретного компьютера (его машинного языка). Это наиболее
сложно для понимания, но также приводит к наиболее полному пониманию способа, которым
должно быть выполнено требуемое выполнение. Xlib предоставляет средства получения определенной комбинации
нулей и единиц для создания определенной функции X Window, так же как язык ассемблера создает
комбинацию нулей и единиц, которая реализует набор инструкций конкретного компьютера. Так же как
определенная инструкция, заданная в программе на языке ассемблера, генерирует байты, которые представляют эту
соответствующую инструкцию по отношению к компьютерному оборудованию, так и определенная функция Xlib создает
байты, которые реализуют ее соответствие в X-протоколе. Наименьшая сложность связана с наборами инструментов, 
такими как GTK, Athena, Motif и т. д. Они соответствуют компилируемым языкам, таким как C,
Fortran, Ada и т. д. в том, что они обеспечивают высокий уровень абстракции вычислительного процесса. Однако,
как в случае с набором инструментов, так и в случае с компилируемым языком, программы, созданные в них, преобразуются
программным обеспечением в элементы самого низкого уровня их конкретной ветви этого стека.

Xlib — это язык C, связанный с X Protocol. Xlib используется в сочетании с программами,
написанными на языке программирования C. При написании программ на C функции Xlib используются
таким же образом, как и с встроенным ассемблером. Xlib — это библиотека функций.

Хотя можно создать пакет протокола X вручную, для практических целей программирования это не очень хорошая идея. Недостатки использования ручного подхода включают:
• нестандартный подход, усложняющий обслуживание программы
• большинство программистов не заинтересованы в протоколе и не понимают его на требуемом уровне

1.3 Проблемы программирования X Window

При программировании с помощью X Window необходимо учитывать следующее:

1. Все окна содержатся в корневом окне;
2. Подокно должно содержаться в своем родительском окне или быть обрезанным;
3. Родительское окно всегда имеет строку заголовка;
4. Меню, кнопки и диалоговые окна рассматриваются как окна;
5. Все измерения длины указаны в пикселях экрана;
6. Каждое окно имеет собственную систему координат

Экран дисплея сервера X Window является корневым окном. Каждое окно, созданное в X Window, содержится в нем. Сервер не пытается изменить размеры окна или изменить его положение, так как окно содержится в корневом окне. Если серверу будет предложено
показать окно, он сделает это, но части окна, выходящие за пределы корневого окна, будут обрезаны.

Все подокна должны отображаться в пределах окна, которое является его родительским. Примером такого подокна является меню. Если это подокно превышает экранные размеры своего родительского окна, то часть этого подокна, которая выходит за пределы, будет удалена менеджером экранов X Window.

Когда создается окно, которое создается с корневым окном в качестве его родителя, будет иметь заголовок.
Содержимое этого заголовка может быть явно назначено в программировании, которое настраивает это окно.

В X Window все является окном. Нет таких специальных сущностей, как меню, кнопки, диалоговые
окна, ползунки, подсветка или 3D-эффекты любого рода. Однако есть несколько исключений. Одним из них является
курсор, используемый для обозначения положения указателя мыши на экране. Кроме того, ни линия, ни символ в шрифте, ни значок не являются окном. Однако во всех этих исключительных случаях каждое из них должно быть нарисовано в на используемом экране. Таким образом, возможно, что внешний вид окна может измениться при просмотре на разных экранах.
Каждое окно имеет свою собственную систему координат. Начало этой системы координат находится в
верхнем левом углу окна. Координата x увеличивается слева направо. Координата y увеличивается сверху вниз окна. Отрицательных координат нет. Все координаты в пикселях экрана.
окне.

Размеры окон и их положение на экране всегда находятся в измерении пикселей экрана. Физический вид окна на экране определяется распределением пикселей на используемом экране. Таким образом, возможно, что внешний вид окна может измениться при просмотре
на разных экранах.

Каждое окно имеет свою собственную систему координат. Начало этой системы координат находится в
верхнем левом углу окна. Координата x увеличивается слева направо. Координата y увеличивается сверху вниз окна. Отрицательных координат нет. Все координаты в пикселях экрана.

2 Getting started.

Программирование в системе X Window сосредоточено на окне. В создании конечного отображаемого изображения может быть задействовано множество окон, а конечный эффект зависит от перекрытия, появления, исчезновения и соседства ряда таких окон и их содержимого. Поэтому освоение программирования в X Window начинается с освоения программирования одного окна. Такое
программирование состоит из четырех основных частей:

1. создание окна;
2. создание этого окна видимым;
3. рисование в этом окне; и
4. обработка ввода в этом окне.

Каждая из этих частей будет обсуждаться и демонстрироваться на примерах в этой и следующих главах.
Каждая из этих частей имеет ряд подчастей. Сложность и, как следствие, мощность и гибкость программирования в X Window являются результатом важных взаимодействий между этими основными частями и их подчастями.
Система X Window определяется своим протоколом. Этот протокол представляет собой серию сообщений, которые
передаются между клиентом и сервером. Клиент — это программа, например, те, которые будут
написаны в этой книге, которые содержат вызовы функций Xlib. Эти вызовы функций генерируют
сообщения протокола, которые отправляются на сервер. Сервер — это часть кода X Window, которая выполняет
запросы, отправленные ему через сообщения протокола. Так, клиентская программа, например, настраивает детали
окна и запрашивает его появление на дисплее. Сервер фактически создает окно на дисплее.

Вызовы функций Xlib являются частью библиотеки, которая предоставляет программисту доступ к
сообщениям протокола. Таким образом, их можно рассматривать как язык ассемблера X Window System. Как и в программировании в целом, существуют языки более высокого порядка. В контексте X Window System они известны как наборы инструментов. Использование наборов инструментов отдаляет программиста от многих (но не всех)
деталей, связанных с программированием протокола X Window System. Во многих случаях это делается
путем предоставления политики, которая становится характеристикой инструментария, для связывания базовых
запросов протокола. Но, как указано в ? (страница xxii), целью создания X Window System было
предоставить механизм, а не политику. В результате Xlib предоставляет наиболее практичные средства исследования
того, чего можно достичь с помощью X Window System. Цена этого понимания заключается в том, что от программиста требуется больше. Исходные программы становятся длиннее, чем те, которые используют инструментарии, и
вероятность упущений увеличивается. Средство помощи программисту в использовании Xlib предоставляется
далее с помощью использования полных, работающих примеров.
В этой главе рассматривается создание окна и его отображение на экране X Window.

2.1 Основные шаги программирования Xlib

Подход к программированию Xlib, предлагаемый здесь, заключается в выполнении ряда шагов. В некоторых случаях
все эти шаги не требуются, как будет показано в примерах, которые приведены ниже в этой книге. В этом
шаговом процессе нет ничего нового. ? предлагает использовать восемь таких шагов, а именно:

1. открыть соединение с сервером с помощью XOpenDisplay
2. создать окно верхнего уровня с помощью XCreateWindow
3. установить стандартные свойства для окна верхнего уровня, включая подсказки для оконного менеджера
4. создать ресурсы окна, такие как графические контексты
5. создать любые другие необходимые окна
6. выбрать нужные события для этих окон
7. сопоставить окна
8. войти в цикл событий

для создания программы Xlib. Затем он приводит код интересной и практичной программы Xlib,
которая, к сожалению, не использует функцию XCreateWindow(), а вместо этого использует XCreateSimpleWindow()
Но этот код помещается на одной печатной странице. Однако этот код необходимо изменить и добавить дополнительные
шаги для выполнения требований текущего выпуска X Window 11 7 по сравнению с выпуском 2, используемым в
этой статье. Эти изменения касаются администрирования и инициализации приложения X Window;
вызовы для создания действия, содержащегося в программе, не изменились.

Девять шагов для создания прикладной программы Xlib с использованием Xlib:

1. открыть соединение с сервером
2. создать окно верхнего уровня
3. дать подсказки диспетчеру окон
4. установить ресурсы окна
5. создать все остальные необходимые окна
6. выбрать события для каждого окна
7. сопоставить окна
8. войти в цикл событий
9. очистить перед выходом

2.2 Создание одного окна

Одной из трудностей программирования X Window является то, что нужно многое сделать, прежде чем что-либо появится на экране дисплея. Если все эти шаги выполнены неправильно, ничего не появится, даже если это почти правильно. Здесь используется простой пример для демонстрации шагов программирования, которые необходимы для получения видимого результата из X Window.

Первый пример тривиален, но он демонстрирует основные процессы, которым необходимо следовать при программировании с использованием Xlib. Пример создает пустое окно заданного размера в цвете по умолчанию на экране дисплея по умолчанию. Рисунок 2.1 показывает полученный вывод. Хотя этот пример тривиален по своему результату, он четко показывает шаги, необходимые для создания функционирующей программы X Window с использованием Xlib. Будет видно, что такие шаги сами по себе не являются тривиальными. Поскольку эти шаги
повторяются со всеми программами Xlib в этой книге, сначала будет представлен шаблон для написания программ Xlib, прежде чем применять его к конкретному примеру. В результате эта глава важна, поскольку она задает тон подходу, используемому в этой книге.

2.2.1 Открытm соединение с сервером

Как описано на странице 126 из ?, каждое клиентское приложение X содержит часть Xlib, встроенную в него во время компиляции. Код приложения вызывает этот код для преобразования вызовов функций Xlib, содержащихся в прикладной программе, в запросы протокола X для части управления этого компонента Xlib для отправки по сети на сервер. Эта часть управления буферизует запросы протокола X, чтобы максимально эффективно использовать сеть между этим клиентом и требуемым сервером. Этот компонент Xlib
также предоставляет структуры данных, которые локально представляют каждый удаленный сервер, к которому клиенту требуется доступ. Затем приложение может получить доступ к этому локальному представлению, чтобы получить информацию о сервере,
не отправляя запросы по сети на сам сервер. Он также буферизует события X, относящиеся к этому приложению, полученные от всех серверов. Каждое приложение X содержит отдельную копию описания каждого сервера, к которому оно подключено.
Структуры Display, Screen и Visual устанавливаются в части Xlib в коде клиента X11,
когда выполняется подключение к серверу. Структура Visual содержит информацию о том, как
представлены цвета для экрана. Структура Screen содержит информацию как о физической
природе (такой как его высота, ширина, черно-белые пиксельные шаблоны, биты на пиксель (глубина) и т. д.), так и о том, как
этот физический экран попадает в модель X11 (например, его корневое окно, цветовая карта по умолчанию, GC
для корня и т. д.). Структура Display содержит информацию, касающуюся формирования пакетов протокола X, которые должны передаваться и приниматься между клиентом и сервером. 
Примеры таких информация, как максимальное количество 32-битных слов в запросе, порядок байтов экрана, используемая строка host:display, номер экрана по умолчанию и количество экранов на сервере. Эти три структуры определены в заголовочном файле Xlib.h.
К членам структур Display, Screen и Visual не осуществляется прямой доступ кодами приложений. В случаях, когда значения по умолчанию, установленные в этих структурах, требуются кодами приложений,
X11 предоставляет одиннадцать функций XDefault* для доступа к таким значениям. Эти функции также
доступны как макросы Default*.
Чтобы использовать X Window, клиентская программа сначала запрашивает соединение с сервером. Это установит в клиентском компоненте Xlib представление сервера в виде структуры Display.
Для этого используется функция XOpenDisplay(). Она возвращает указатель на приложение структуры Display, хранящейся в компоненте Xlib клиентской программы. Эта структура описывает подробную информацию о конфигурации сервера. XOpenDisplay() реализуется с помощью запроса CreateGC protocol (STRANGE). Информация, содержащаяся в этих структурах, доступна клиентскому приложению
через макросы Default.

2.2.2 Окно верхнего уровня

Приложение X Window состоит только из окон. X Window предоставляет только один тип окна, но его можно оборудовать по-разному для разных целей. В других системах управления окнами нет специализированных кнопок, полос прокрутки, полей ввода текста и т. д. Каждый из этих элементов может быть создан из окна или комбинации более чем одного окна в X Window. X Window предоставляет
свободу комбинирования в рамках ограничения иерархических отношений между окнами. Таким образом, X Window, как говорят, предоставляет механизм без навязывания политики. Именно эта общность делает X Window одновременно мощным и сложным для программиста, поскольку доступно большое количество опций.
Все окна в X Window образуют иерархию. Родительское окно может содержать подокна, а эти подокна могут содержать подокна и т. д. Эти отношения образуют иерархию, в которой родитель является корнем иерархического дерева. Поверхность экрана, занимаемая такими подокнами, должна попадать
внутрь области поверхности, определенной для ее родителя. Эти родители могут быть результатом независимых или взаимозависимых запущенных программ, и их распределение области поверхности экрана может быть разделено или перекрываться, перекрываться полностью или частично. В соответствии с иерархией окон, эти родительские окна
сами являются подокнами главного окна, называемого корневым окном. Это корневое окно управляется
менеджером окон.
Когда окно инициализируется, ему необходимо указать своего родителя. В случае окна верхнего уровня
этот родитель является корневым окном. Как описано в Разделе 2.2.1, первое действие, которое выполняет клиентская программа,
заключается в использовании вызова XOpenDisplay() для создания структур данных Display, Screen и Visual в части Xlib исполняемого кода клиента. Эти структуры поддерживают иерархическую структуру окна,
которую клиентская программа затем строит и впоследствии использует.
Для создания окна доступны два вызова Xlib; XCreateSimpleWindow() и XCreateWindow(). Вызов XCreateWindow() имеет большую общность и используется здесь.
Допустим, код на рисунке 2.2 содержится в файле basic.c. В системе Linux, использующей gcc
версии 4.1.1 и X11 версии 7.1.0, этот код компилируется и связывается с командой оболочки:

gcc -o basic -I /usr/include/X11 -L /usr/X11R6/lib -lX11 basic.c

Полученный исполняемый файл basic затем запускается с помощью команды оболочки:

./basic &

#include <X11/Xlib.h>
#include <X11/Xutil.h>

int main(int argc, char* argv[])
{
    Display *mydisplay;
    XSetWindowAttributes myat;
    Window mywindow;
    XSizeHints wmsize;
    XWMHints wmhints;
    XTextProperty windowName, iconName;
    XEvent myevent;
    char *window_name = "Basic";
    char *icon_name = "Ba";
    int screen_num, done;
    unsigned long valuemask;

    /* 1. открыть соединенте с сервером X window */
    mydisplay = XOpenDisplay("");

    /* 2. создать верхнеуровневое (root) окно */
    screen_num = DefaultScreen(mydisplay);
    myat.background_pixel = WhitePixel(mydisplay, screen_num);
    myat.border_pixel = BlackPixel(mydisplay, screen_num);
    myat.event_mask = ButtonPressMask;
    valuemask = CWBackPixel | CWBorderPixel | CWEventMask;
    mywindow = XCreateWindow(mydisplay, RootWindow(mydisplay, screen_num), 
                            200, 200, 600, 400, 2,
                            DefaultDepth(mydisplay, screen_num), InputOutput, 
                            DefaultVisual(mydisplay, screen_num), 
                            valuemask, &myat);

    /* 3. дайте подсказки диспетчеру окон */

    wmsize.flags = USPosition | USSize;
    XSetWMNormalHints(mydisplay, mywindow, &wmsize);
    wmhints.initial_state = NormalState;
    wmhints.flags = StateHint;
    XSetWMHints(mydisplay, mywindow, &wmhints);
    XStringListToTextProperty(&window_name, 1, &windowName);
    XSetWMName(mydisplay, mywindow, &windowName);
    XStringListToTextProperty(&icon_name, 1, &iconName);
    XSetWMIconName(mydisplay, mywindow, &iconName);

    /*     4. Установить ресурсы окон  */
    /*  5. Создать все остальные необходимые окна  */
    /*  6. Выбрать события для каждого окна  */
    /*  7. Сопоставить окна  */

    XMapWindow(mydisplay, mywindow);

    done = 0;
    while (done == 0)
    {
        XNextEvent(mydisplay, &myevent);
        switch (myevent.type)
        {
        case ButtonPress:
            break;
        }
    }
    XUnmapWindow(mydisplay, mywindow);
    XDestroyWindow(mydisplay, mywindow);
    XCloseDisplay(mydisplay);   
    return 0;

}

Что касается примера X Window на рисунке 2.2, следует отметить следующее:

• Это, возможно, самый простой пример из возможных;
• В примере нет способа завершить выполнение. В системе Unix это можно сделать с помощью ps из оболочки для поиска идентификатора процесса исполняемого кода и использования этого идентификатора в команде kill из оболочки для завершения этого процесса.
• 9 шагов показаны как комментарии, но используются только 5;
• Из-за способа завершения программы шаг 9 не является необходимым,
потому что он никогда не будет выполнен;
• Использование максимального количества значений по умолчанию было использовано для сокращения размера примера
до минимума;
• Цикл событий шага 8 необходим, иначе на экране сервера не появится окно.
Попробуйте удалить этот цикл, чтобы проверить это утверждение. Цикл требуется для обеспечения обработки событий, которая необходима для функционирования Xlib.
• Важно. Та же переменная типа XEvent должна использоваться в вызове функции XNextEvent() и во всей последующей обработке этого события. В этом примере это происходит только в операторе switch.

На рисунке 2.1 показано, что появляется на экране при выполнении программы на рисунке 2.2. Этот
пример только создает окно и размещает его на экране. Это окно пустое. Примечание: при
создании окна графический контекст (GC) не задействован (см. далее). Графический контекст задействован только при рисовании в этом окне — графический контекст связан с операциями рисования.
На рисунке 2.1 показаны некоторые дополнения. К ним относятся оформление окна и окружающий черно-белый узор из точек корневого окна, используемого на компьютере, с которого был сделан снимок экрана. Они будут отображаться на всех снимках экрана на следующих страницах. Они являются свойством диспетчера окон X11, что выходит за рамки данной текущей работы.

Примечание: большинство приложений X Window начинаются как каркас, прикрепленный к указателю на экране.
При нажатии кнопки мыши диспетчер окон рисует окно, содержащееся в коде, например, как на рисунке 2.1. Этого не происходит, когда код рисунка 2.2 или любая другая программа, содержащаяся в этой работе. Вместо этого начальное окно рисуется на экране в позиции, назначенной в вызове XCreateWindow(). Это изменение в поведении связано с XSetWMNormalHints() вызов. Этот вызов предоставляет диспетчеру окон на компьютере, выполняющем код, дополнительную информацию, без которой пользователю предлагается предоставить ее с помощью указателя мыши.

2.2.3 Упражнения

1. Измените код на рисунке 2.2 так, чтобы была реализована проверка ошибок.
2. Какое простое изменение можно внести в код на рисунке 2.2, чтобы щелчок мышью
в любом месте в пределах белого окна приводил к завершению программы?
3. Какое простое изменение можно внести в код на рисунке 2.2, чтобы щелчок мышью
внутри пределов белого окна вызывал звук колокольчика каждый раз при щелчке мышью?
4. Измените код на рисунке 2.2 так, чтобы белое окно окрасилось в желтый цвет.
5. Найдите выборку диспетчеров окон, в которых использование вызова XSetWMNormalHints() имеет указанный выше эффект, а в
том числе нет. Например, подсказки имеют эффект в twm, но не в dwm. Почему это происходит и как это влияет на использование кода, реализованного в X Window?


2.3 Наименьшая программа Xlib для создания окна


Код на рисунке 2.2 включает все части, рекомендуемые для включения при написании программы Xlib. Этот подход будет использоваться во всех последующих примерах. Но он также реализует политику в предоставлении поддержки базового оконного менеджера. Однако X Window был разработан для предоставления механизма, а не политики. Итак, какой наименьший объем кода Xlib требуется для создания
окна на экране? Код на рисунке 2.3 является ответом.
При выполнении код на рисунке 2.3 создает окно на экране, такое же, как показано

на рисунке 2.1. В коде ряд параметров остаются неуказанными, например, цвет
границы окна. Значения по умолчанию для этих параметров предоставляются либо X-сервером, либо
используемым оконным менеджером. Поскольку код не предоставляет заголовок, окно имеет заголовок Untitled
оконным менеджером. Менеджеру окон не даются подсказки, помогающие ему отобразить
окно, но менеджер окон выполняет свою работу. В программе используются четыре основных вызова Xlib с четырьмя вспомогательными вызовами. Хотя с окном не связаны никакие события, для появления окна требуется вызов Xlib XNextEvent(). Поскольку в переменной myevent не указаны никакие события, вызов XNextEvent() генерирует неопределенное ожидание. Без этого вызова на экране ничего не отображается.


2.3.1 Упражнения

1. Перечислите Xlib и вспомогательный вызов в программе на рисунке 2.3.
2. Измените код на рисунке 2.3 так, чтобы окно было окрашено в зеленый цвет.
3. Какие части кода на рисунке 2.2, которые не включены в рисунок 2.3, реализуют политику?
4. Какова цель вызова XNextEvent() в программе на рисунке 2.3? Что происходит, когда этот вызов удаляется?


#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
    Display *mydisplay;
    XSetWindowAttributes myat;
    Window mywindow;
    XEvent myevent;
    int screen_num, done;
    unsigned long valuemask;
    
    /* 1. открыть соединенте с сервером X window */
    mydisplay = XOpenDisplay("");
    if (mydisplay == NULL)
    {
        printf("Can't connect X server: %s\n", strerror( errno ));
        exit(1);
    }
    

    /* 2. создать верхнеуровневое (root) окно */
    screen_num = DefaultScreen(mydisplay);
    myat.background_pixel = WhitePixel(mydisplay, screen_num);
    myat.border_pixel = BlackPixel(mydisplay, screen_num);
    valuemask = CWBackPixel;
    /* создаём окно с полным набором атрибутов*/
    mywindow = XCreateWindow(mydisplay, 
                            RootWindow(mydisplay, screen_num),  // родительское окно 
                            200, 200,                           // координаты левого верхнего угла
                            600, 400,                           // ширина и высота окна
                            2,                                  // толщина рамки вокруг окна
                            DefaultDepth(mydisplay, screen_num),// количество разрядов, для кодирования цвета   
                            /* класс окна. Допустимые значения: 
                            InputOutput (ввод и вывод), 
                            InputOnly (только ввод) 
                            или CopyFromParent (установить тип как у окна-предка) */
                            InputOutput,                         // класс окна ввод и вывод
                            DefaultVisual(mydisplay, screen_num),// визуальные характеристики окна. 
                                                                 // Если указать CopyFromParent, данные будут взяты у окна-предка; 
                            valuemask,                           // маска, указывающая, какие параметры из аргумента attributes следует указывать; 
                            &myat);                              // 

    /* 3. дайте подсказки диспетчеру окон */
   
    /*     4. Установить ресурсы окон  */
    /*  5. Создать все остальные необходимые окна  */
    /*  6. Выбрать события для каждого окна  */
    /*  7. Сопоставить окна  */

    XMapWindow(mydisplay, mywindow); // Сделать окно видимым

    XNextEvent(mydisplay, &myevent);
    
    return 0;

}

2.4 Простая, но полезная программа X Window

Программа на рисунке 2.4 предлагается в качестве контраргумента к аргументу о том, что программы Xlib сложны
и длинны, если они должны делать что-то полезное. Было бы неплохо, если бы такая программа также могла быть полезной.
Программа здесь издает звуковой сигнал компьютера. Окно не создается и не отображается. Программе
необходимо открыть соединение с дисплеем, и в этой программе используется дисплей системы по умолчанию. Звонок связан с дисплеем.
Звонок — одна из ряда служб, предоставляемых сервером. Клиентская программа отправляет
запросы протокола X на сервер, который затем инициирует запрошенную функцию. Для большинства

#include <X11/Xlib.h>
#include <X11/Xutil.h>


int main(int argc, char* argv[])
{
    Display *mydisplay;

    /* открыть соединенте с X сервером*/
    mydisplay = XOpenDisplay("");

    /* 2 . создать окно верхнего уровня */
    /* 3 . дать подсказки диспетчеру окон */
    /* 4 . установить ресурсы окон */
    /* 5 . создать все остальные необходимые окна */
    /* 6 . выбрать события для каждого окна */
    /* 7 . сопоставить окна */
    /* 8 . ввести цикл событий */

    XBell(mydisplay, 0);

    /* 9. Закрыть соединенте с сервером */
    XCloseDisplay(mydisplay);
    return 0;
}

таких запросов сервер использует ядро ​​операционной системы базового компьютера для выполнения
запроса. Другими примерами таких запросов являются рисование на дисплее, управление мышью и
операции с клавиатурой. Каждый из этих типов запросов рассматривается в следующих главах. Размер клиентской
программы, использующей такие запросы, увеличивается по мере увеличения сложности, доступной в таких запросах.

2.4.1 Упражнения

1. Измените программу на рисунке 2.4 так, чтобы программа воспроизводила самый громкий звонок.
2. Добавьте в программу на рисунке 2.4, чтобы пользователь задавал уровень громкости звонка.
3. Перечислите 5 случаев, когда можно применить программу на рисунке 2.4.

2.5 Движущееся окно

Как покажет следующая работа, графический пользовательский интерфейс (GUI) состоит из многих частей, и
эти части реализованы как отдельные, но связанные окна. Эта ориентация окна сильнее
при использовании Xlib, чем при использовании таких наборов инструментов, как Xt, Motif и Gtk, которые используют X Window System,
и прикладной программный интерфейс (API) Microsoft Windows. Немногие программы, использующие
окна, состоят из одного окна.
В этом разделе второе окно добавляется к окну, созданному программой на рисунке 2.2.

Это показывает, что одно дополнительное окно требует усилий по программированию, но меньше, чем требуется для формирования первого/фонового окна, хотя это фоновое окно также требуется.
Аналогичное количество усилий требуется для каждого последующего окна, добавляемого для формирования коллектива
GUI. На рисунке 2.5 показаны два примера из полученного результата.

Создается окно с именем rover размером 50 пикселей по горизонтали на 70 пикселей по вертикали черного цвета. Это окно является дочерним по отношению к фоновому окну с именем mywindow, которое имеет белый цвет.
Дочернее окно перемещается по родительскому окну. Это делается путем изменения положения,
где должно отображаться дочернее окно. Когда окно создается с помощью вызова XCreateWindow() (или XCreateSimpleWindow()) Xlib, необходимо задать положение для отображения этого окна.
Это положение относительно системы координат (в единицах пикселей экрана), прикрепленной к родительскому окну создаваемого окна. Оно фиксируется после создания окна. Однако для изменения этого положения можно использовать структуру XWindowChanges,
обрабатываемую вызовом XConfigureWindow() Xlib. Новое положение — это положение, в котором окно появится на экране при следующем отображении.
Но окно может появиться на экране только один раз. Итак, если после вызова XMapWindow() было
сделано для отображения окна в исходной позиции, последующий вызов XMapWindow() с отменой (удалением) окна с экрана и отображением его в новой позиции. Промежуточный вызов XUnmapWindow() не нужен. Это отличается от способа, которым X Window обрабатывает растровые
шаблоны, который обсуждается в Разделе 4.2.

Как и при создании окна с помощью вызова функции XCreateWindow() Xlib, маска значений
используется для указания параметров в структуре XWindowChanges, которые XConfigureWindow()
должен изменить. В этом случае обе координаты положения должны быть изменены, что указывается
логическим ИЛИ битовых спецификаторов CWX и CWY. Требуемые значения этих координат
присваиваются соответствующей записи в переменной типа XWindowChanges перед ее использованием в вызове XConfigureWindow(). Это видно в программе на рисунке 2.6, которая создала экранное показание на рисунке 2.5.

Эта программа управляется событиями, которые создает код в программе. События являются центральными
для X Window и обсуждаются в разделе 3.3: Большинство программ X Window используют события. Чтобы указать
изменение конфигурации (в данном случае положения) окна, StructureNotifyMask
вставляется в маску событий, используемую при создании двух окон программы. Цикл событий программы содержит случай ConfigureNotify для выполнения обработки, когда вызов XConfigureWindow изменяет положение окна. Эта pprocessing заключается в сопоставлении (отображении) окна с его новыми координатами, ожидании 3 секунды перед выбором следующего положения окна.
Задержка в 3 секунды позволяет наблюдать отдельные изменения положения окна на
экране. Задержка создается системным вызовом sleep(), которому требуется заголовочный
файл unistd.h. Событие воздействия, используемое в программе на рисунке 2.6, на самом деле не является необходимым в данном конкретном случае.

/* Сначала создается базовое окно с белым фоном. 
 Затем создается еще одно
 окно, дочернее первого, с черным фоном. Это
 второе окно повторно отображается на свое родительское окно, а затем удаляется
 через 3 секунды. Каждое отображение находится в другом месте. */

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
    Display *mydisplay;
    XSetWindowAttributes myat;
    Window mywindow, rover;
    XWindowChanges alter;
    XSizeHints wmsize;
    XWMHints wmhints;
    XTextProperty windowName, iconName;
    XEvent myevent;
    char *window_name = "Walking";
    char *icon_name = "Wk";
    int screen_num, done;
    unsigned long valuemask;
    char *msg = "Hello world"; 
    int x, y;

     /* 1. открыть соединенте с сервером X window */
    mydisplay = XOpenDisplay("");
    if (mydisplay == NULL)
    {
        printf("Can't connect X server: %s\n", strerror( errno ));
        exit(1);
    }
    
    /* 2. создать верхнеуровневое (root) окно */
    screen_num = DefaultScreen(mydisplay);
    myat.background_pixel = WhitePixel(mydisplay, screen_num);
    //myat.background_pixel = 0x1F1F1FFF;
    myat.border_pixel = BlackPixel(mydisplay, screen_num);
    myat.event_mask = ExposureMask | StructureNotifyMask;   //событие по изменению окна
    valuemask = CWBackPixel | CWBorderPixel | CWEventMask;
    /* создаём окно с полным набором атрибутов*/

     mywindow = XCreateWindow(mydisplay, 
                            RootWindow(mydisplay, screen_num),  // родительское окно 
                            200, 200,                           // координаты левого верхнего угла
                            600, 400,                           // ширина и высота окна
                            2,                                  // толщина рамки вокруг окна
                            DefaultDepth(mydisplay, screen_num),// количество разрядов, для кодирования цвета   
                            /* класс окна. Допустимые значения: 
                            InputOutput (ввод и вывод), 
                            InputOnly (только ввод) 
                            или CopyFromParent (установить тип как у окна-предка) */
                            InputOutput,                         // класс окна ввод и вывод
                            DefaultVisual(mydisplay, screen_num),// визуальные характеристики окна. 
                                                                 // Если указать CopyFromParent, данные будут взяты у окна-предка; 
                            valuemask,                           // маска, указывающая, какие параметры из аргумента attributes следует указывать; 
                            &myat);                              // 
    /* 3. дайте подсказки диспетчеру окон */

    wmsize.flags = USPosition | USSize; // запрашивать у пользователя позицию и размер
                                        // можно двигать и менять размер
    XSetWMNormalHints(mydisplay, mywindow, &wmsize); //Установка геометрических параметров окна для нормального состояния
    wmhints.initial_state = NormalState; // обычное состояние
    wmhints.flags = StateHint;
    XSetWMHints(mydisplay, mywindow, &wmhints); // Установка атрибутов окна для оконного менеджера
    XStringListToTextProperty(&window_name, 1, &windowName);
    XSetWMName(mydisplay, mywindow, &windowName); // 
    XStringListToTextProperty(&icon_name, 1, &iconName);
    XSetWMIconName(mydisplay, mywindow, &iconName);

    /*     4. Установить ресурсы окон  */
    /*  5. Создать все остальные необходимые окна  */

    myat.background_pixel = BlackPixel(mydisplay, screen_num);
    rover = XCreateWindow(mydisplay, mywindow, 
                          100, 300, 50, 70, 2,
                          DefaultDepth(mydisplay, screen_num),
                          InputOutput,
                          DefaultVisual(mydisplay, screen_num),
                          valuemask, &myat);
    /*  6. Выбрать события для каждого окна  */
    valuemask = CWX | CWY;
    /*  7. Сопоставить окна  */

    XMapWindow(mydisplay, mywindow); // Сделать окно видимым
    done = 0;
    x = 11, y = 12;
    while(done == 0)
    {
        alter.x = x;
        alter.y = y;
        XConfigureWindow(mydisplay, rover, valuemask, &alter);
        XFlush(mydisplay);
        XNextEvent(mydisplay, &myevent);
        switch (myevent.type)
        {
        case Expose :
            XDrawString(mydisplay, mywindow, DefaultGC( mydisplay, screen_num ), 
                        50, 50, msg, strlen(msg));
            break;
        case ConfigureNotify:
            XMapWindow(mydisplay, rover);
            sleep(3);
            x += 5, y += 6;
        default:
            break;
        }
    }

    XUnmapWindow(mydisplay, mywindow);
    XDestroyWindow(mydisplay, mywindow);
    XCloseDisplay(mydisplay);   
    exit(0);

}


X Window пытается оптимизировать отправку сообщений между клиентской программой и сервером, который
отвечает за обработку окон, событий и т. д. Очередь запросов сообщений клиента предоставляется Xlib
как часть клиентской программы, и сервер поддерживает полученную очередь запросов. Когда событие
происходит, сервер немедленно (за исключением случаев, когда задействованы захваты) отправляет сообщение о событии в очередь событий,
поддерживаемую Xlib в клиентской программе. Вызов XNextEvent() в цикле событий клиентской программы
обрабатывает следующее событие в этой очереди событий клиента. Если очередь пуста, клиент
очищает свою очередь запросов и ждет сообщения о событии от сервера. Таким образом, вызов XNextEvent()
немедленно отправит запрос на сервер только в том случае, если очередь событий клиента пуста. Чтобы принудительно отправить немедленный запрос сервера, можно использовать вызов XFlush(). Это делается в коде
Рисунок 2.6, чтобы гарантировать, что сервер немедленно отреагирует на изменение положения окна, содержащееся в вызове
XConfigureWindow(). Любые события, которые сервер может отправить в очередь событий клиентской программы в результате очищенного запроса, обрабатываются после событий, уже находящихся в очереди событий клиента.

2.5.1 Упражнения

1. Вставьте дополнительный код в программу на рисунке 2.6 для проверки на наличие ошибок.
2. Какие параметры созданного окна можно изменить, кроме положения, в котором оно должно
отображаться?
3. Какие события учитываются при рассмотрении окна, когда StructureNotifyMask
включается в маску событий, указанную при его создании?
4. Приведите три примера событий экспозиции, обнаруживаемых сервером X Window, которые потребуют обработки клиентской программой.
5. Черное окно, созданное программой на рисунке 2.6, в конечном итоге исчезает с экрана. Почему это происходит? Опишите задействованный механизм системы X Window.

2.6 Части окон могут исчезать из вида

Окно — это строительный блок, из которого сделаны все приложения X Window. Каждое окно — это
прямоугольная область на экране. Эти окна обладают свойством формирования иерархии, так что
все окна связаны друг с другом повторяющейся парой родитель/потомок, в которой у одного родителя может
быть один или несколько потомков. На экране окно потомка обрезается сервером X Window,
поэтому оно содержится внутри окна своего родителя. Такая группировка семейств делает весьма вероятным, что
два или более окон будут занимать одно и то же место на экране. Но сервер X Window размещает
все окна на экране одно за другим. Таким образом, если два или более окон занимают одно и то же место на экране, окно или часть окна может быть закрыто от просмотра на экране другим окном. Искусство программирования X Window заключается в том, чтобы гарантировать, что соответствующая информация для пользователя-человека, которая находится в разных окнах, одновременно доступна на экране с учетом ограничений
системы X Window.

Что происходит, когда окно, закрывающее одно или несколько других окон или частей окон, удаляется с экрана? Для ответа на этот вопрос необходимо знать составные части X, а также то, как они взаимодействуют. Этот вопрос является следствием наличия более одного окна на экране. Большинство графических пользовательских интерфейсов (GUI) построены из нескольких окон. В результате ответ имеет практическое значение. Чем больше окон на экране, тем больше вероятность того, что придется иметь дело с последствиями ответа. Каждое окно имеет прямоугольную форму, имеет границу, передний план и фон. Все рисование в окне выполняется с использованием переднего плана этого окна. Рисование на переднем плане окна выполняется с использованием графического контекста (GC), который имеет ряд параметров, включая передний план и фон. Фон окна можно настроить так, чтобы он содержал визуальный узор, без использования GC. Память для структур Xlib, объявленных в клиентской программе, (в большинстве случаев) не становится частью клиентской программы, но является частью сервера. К такой памяти сервера обращаются
запросы протокола, которые являются результатом вызовов Xlib, содержащихся в коде клиентской программы.

Когда окно создается клиентской программой, размер окна, положение, которое оно должно занимать
на экране, внешний вид его границы и содержимое его фона сохраняются как изображение в
памяти сервера. Затем клиентская программа может запросить сервер отобразить (отобразить) это изображение на
экране. Клиентская программа также может запросить сервер удалить (отменить отображение) это изображение с
экрана. Отмена отображения изображения не обязательно уничтожает изображение окна на сервере.
Естественно ожидать, что когда окно отменяется, любые окна, которые оно частично скрывает,
станут полностью видимыми. В конце концов, информация обо всех окнах уже есть на сервере. Сервер должен
позаботиться о восстановлении. Окно может запросить вызов XCreateWindow() (или XCreateSimpleWindow()) в клиентской программе для создания окна для сервера, чтобы предоставить такую ​​услугу. Существует две такие услуги: сохранение под и резервное хранилище. Программа, показывающая, как выполняются такие запросы на обслуживание, будет приведена вскоре. Однако сервер может не предоставлять такие услуги. Это особенно актуально для серверов из более поздних выпусков X Window System. Если клиентская программа требует такие службы и они недоступны, качество производительности клиентской программы отрицательно влияет.

В вводной главе по программированию Xlib может показаться неуместным рассматривать поведение сервера, особенно связанное с восстановлением после наложения окон. Но взаимодействие сервера и клиентской программы лежит в основе X. Упрощенно говоря, клиент запрашивает у сервера выполнение операций. У сервера есть функции, которые он может выполнять, но они могут не соответствовать ожидаемым.
Все программы Xlib должны выполняться в клиент-серверной среде, которую предоставляет X.
Элементы, которые здесь представлены для рассмотрения этой темы, используются и расширяются во всем, что следует.

2.6.1 Тестирование служб наложения, доступных с X-сервера

Ни один X-сервер не гарантирует предоставления служб сохранения или резервного хранилища. Поэтому любой конкретный X-сервер
либо будет, либо не будет предоставлять такие службы. Программа на рисунке 2.7 проверяет, предоставляются ли такие службы. 
Результаты проверки отправляются на стандартный вывод.

Службы сохранения и резервного хранилища немного отличаются. При сохранении содержимое экрана,
на который отображено окно, сохраняется сервером в момент отображения окна, используя память сервера. Когда это окно отменяется, сервер перемещает свою копию исходного содержимого экрана, занятого удаленным окном, обратно на экран. Это,
как правило, небольшие области экрана, скажем, те, которые возникают в результате формирования окна как пункта меню. Однако, это восстановленное содержимое может быть из более чем одного окна. При резервном хранилище содержимое
целого окна сохраняется в памяти сервера. Сервер обнаруживает, что окно будет
полностью или частично закрыто, и зная, что у окна включено резервное хранилище, все содержимое
этого окна сохраняется. Когда окно, вызвавшее сохранение, отменяется, все содержимое окна, имеющего резервное хранилище, перерисовывается сервером на экране. Клиентская программа,после определения того, какие окна должны сохраняться, и атрибутов резервного хранилища,
не участвует в реализации этих служб. Клиентская программа может, однако, запросить у сервера уведомление о выполнении таких действий.

2.6.2 Последствия отсутствия серверных оверлейных служб

Для демонстрации наложения окон и того, что может произойти, если одно или несколько из них будут удалены с экрана, используется программа, управляющая четырьмя окнами. Четыре окна (mywindow, win1, win2 и ontop) создаются с использованием атрибутов окна структуры myat с переменной valuemask, указывающей, какие атрибуты окна были запрошены. Окна win1, win2 и ontop
являются дочерними элементами окна mywindow. Программа рассматривает передний план и фонкаждого окна отдельно.
Фон окон mywindow, win1 и win2 установлен белым цветом.
Фон четвертого окна, ontop, установлен черным цветом.
Фон базового окна (mywindow) выложен плиткой с черно-белым узором шахматной доски, который был создан извне с помощью служебной программы bitmap. Этот узор хранится в виде битовой карты в массиве backing_bit, который имеет связанные переменные backing_width и backing_height
Свойство плитки окна повторяет этот 16x16 пикселей на фоне 350x250 пикселей окна mywindow. Сначала битовая карта преобразовано в пиксельную карту, названную back вызовом функции Xlib XCreatePixmapFromBitmapData(). Эта пиксельная карта вставляется в фон
mywindow вызовом функции Xlib XSetWindowBackgroundPixmap().
Передний план окон win1, win2 и ontop должен быть окрашен в черный цвет. Такой окраска выполняется как частный случай рисования на переднем плане. X Window требует использования графического контекста (GC) при выполнении любых операций рисования на переднем плане окна. Сам GC имеет как передний план, так и фон, цвет обоих должен быть указан. Это делается в программе на рисунке 2.8 с использованием функций Xlib XSetForeground() и XSetBackground() соответственно.

/* A program to check whether the Xserver provides Backing store and
    Save under. */

#include <X11/Xlib.h>
#include <stdio.h>

int main(int argc, char *argv[])
{
    Display *e6display;
    Screen *screenptr;
    int screen_num;

    e6display = XOpenDisplay("");
    screen_num = DefaultScreen(e6display);
    screenptr = ScreenOfDisplay(e6display, screen_num);

    printf("Macro = %d\n", DoesSaveUnders(screenptr));
    if (DoesSaveUnders(screenptr))
        printf("Does screen unders\n");
    else
        printf("Does NOT screen unders\n");

    switch (DoesBackingStore(screenptr))
    {
    case WhenMapped :
        printf("Backing store provided when window is mapped\n");
        break;
    case Always :
        printf("Backing store is always provided\n");
        break;
    case NotUseful :
        printf("Dose not provided Backing store\n");
        break;                    
    default:
        printf("Something wrong with DoesBackingStore() call\n");;
    }    

    XCloseDisplay(e6display);
}


После того, как окна были созданы, они отображаются (отображаются) на экране с помощью функции XMapWindow() Xlib. На рисунке 2.9 показаны четыре снимка действий программы на рисунке 2.8. Изначально родительское окно mywindow и два его дочерних окна win1 и win2 находятся на экране, как показано на рисунке 2.9(a). Пиксельная карта в виде шахматной доски на фоне родительского окна является
доминирующей функцией.


/* Сначала рисуется окно с черно-белым шахматным узором. Затем на этом окне рисуются два
 прямоугольника. Фон каждого из этих
 двух окон белый. Затем создается GC с передним
 цветом черного. Этот GC используется для рисования переднего плана двух окон
 черным цветом. Третий создается с черным фоном и отображается
 поверх двух окон. Это наложенное окно затем удаляется. Этот
 процесс управляется событием с задержкой в ​​2 секунды в цикле событий.
 */

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define backing_width 16
#define backing_height 16
static unsigned char backing_bits[] = {
0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff } ;

int main(int argc, char *argv[])
{
    Display *mydisplay;
    XSetWindowAttributes myat;
    Window mywindow, win1, win2, ontop;
    XWindowChanges alter;
    XSizeHints wmsize;
    XWMHints wmhints;
    XTextProperty windowName, iconName;
    XEvent myevent;
    GC gc;
    char *window_name = "Uncover";
    char *icon_name = "Uc";
    int screen_num, done;
    unsigned long valuemask;
    Pixmap back;
    int count;

    /* 1. открыть соединенте с сервером X window */
    mydisplay = XOpenDisplay("");
    if (mydisplay == NULL)
    {
        printf("Can't connect X server: %s\n", strerror( errno ));
        exit(1);
    }

    /* 2. создать верхнеуровневое (root) окно */
    screen_num = DefaultScreen(mydisplay);
    myat.background_pixel = WhitePixel(mydisplay, screen_num);
    //myat.background_pixel = 0x1F1F1FFF;
    myat.border_pixel = BlackPixel(mydisplay, screen_num);
    myat.event_mask = ButtonPressMask | ExposureMask;
    myat.save_under = True;
    valuemask = CWBackPixel | CWBorderPixel | CWEventMask | CWSaveUnder;

    printf("создаём окно с полным набором атрибутов\n");
    /* создаём окно с полным набором атрибутов*/
    mywindow = XCreateWindow(mydisplay, 
                            RootWindow(mydisplay, screen_num),  // родительское окно 
                            200, 200,                           // координаты левого верхнего угла
                            600, 400,                           // ширина и высота окна
                            2,                                  // толщина рамки вокруг окна
                            DefaultDepth(mydisplay, screen_num),// количество разрядов, для кодирования цвета   
                            /* класс окна. Допустимые значения: 
                            InputOutput (ввод и вывод), 
                            InputOnly (только ввод) 
                            или CopyFromParent (установить тип как у окна-предка) */
                            InputOutput,                         // класс окна ввод и вывод
                            DefaultVisual(mydisplay, screen_num),// визуальные характеристики окна. 
                                                                 // Если указать CopyFromParent, данные будут взяты у окна-предка; 
                            valuemask,                           // маска, указывающая, какие параметры из аргумента attributes следует указывать; 
                            &myat);                              // 
    printf("создаём Pixmap\n");
    back = XCreatePixmapFromBitmapData(mydisplay, mywindow,
                                    (char*) backing_bits, backing_width, backing_height,
                                    BlackPixel(mydisplay, screen_num),
                                    WhitePixel(mydisplay, screen_num), 
                                    DefaultDepth(mydisplay, screen_num));                        

    printf("Задаём фон Pixmap\n");     
    XSetWindowBackgroundPixmap(mydisplay, mywindow, back);

     /* 3. дайте подсказки диспетчеру окон */

    wmsize.flags = USPosition | USSize; // запрашивать у пользователя позицию и размер
                                        // можно двигать и менять размер
    XSetWMNormalHints(mydisplay, mywindow, &wmsize); //Установка геометрических параметров окна для нормального состояния
    wmhints.initial_state = NormalState; // обычное состояние
    wmhints.flags = StateHint;
    XSetWMHints(mydisplay, mywindow, &wmhints); // Установка атрибутов окна для оконного менеджера
    XStringListToTextProperty(&window_name, 1, &windowName);
    XSetWMName(mydisplay, mywindow, &windowName); // 
    XStringListToTextProperty(&icon_name, 1, &iconName);
    XSetWMIconName(mydisplay, mywindow, &iconName);

    /*     4. Установить ресурсы окон  */
    gc = XCreateGC(mydisplay, mywindow, 0, NULL);
    XSetForeground(mydisplay, gc, BlackPixel(mydisplay, screen_num));
    XSetBackground(mydisplay, gc, WhitePixel(mydisplay, screen_num));

    /*  5. Создать все остальные необходимые окна  */
    win1 = XCreateWindow(mydisplay, mywindow, 
                          100, 30, 50, 70, 2,
                          DefaultDepth(mydisplay, screen_num),
                          InputOutput,
                          DefaultVisual(mydisplay, screen_num),
                          valuemask, &myat);
    win2 = XCreateWindow(mydisplay, mywindow, 
                          120, 40, 80, 130, 2,
                          DefaultDepth(mydisplay, screen_num),
                          InputOutput,
                          DefaultVisual(mydisplay, screen_num),
                          valuemask, &myat);                      
    myat.background_pixel = BlackPixel(mydisplay, screen_num);
    ontop = XCreateWindow(mydisplay, mywindow, 
                          120, 40, 80, 130, 2,
                          DefaultDepth(mydisplay, screen_num),
                          InputOutput,
                          DefaultVisual(mydisplay, screen_num),
                          valuemask, &myat);
    /*  6. Выбрать события для каждого окна  */
    /*  7. Сопоставить окна  */
    XMapWindow(mydisplay, mywindow); // Сделать окно видимым
    XMapWindow(mydisplay, win1); // Сделать окно видимым
    XMapWindow(mydisplay, win2); // Сделать окно видимым

    done = 0;
    count = 0;
    while (done == 0)
    {
        XFlush(mydisplay);
        XNextEvent(mydisplay, &myevent);
        sleep(2);
        switch (myevent.type)
        {
        case Expose :
            /* code */
            count++;
            switch (count)
            {
            case 1:
                XFillRectangle(mydisplay, win1, gc, 0, 0, 50, 70);
                XFillRectangle(mydisplay, win2, gc, 0, 0, 150, 30);
                break;
            case 3:
                XMapWindow(mydisplay, ontop);
                break;
            case 6:
                XUnmapWindow(mydisplay, ontop);
                break;    
            case 9:
                XUnmapWindow(mydisplay, win2);
                break;        
            default:
                break;
            }
            break;
        case ButtonPress:
            done = 1;
            break;    
        default:
            break;
        }
    }
    
    
    XUnmapWindow(mydisplay, mywindow);
    XDestroyWindow(mydisplay, mywindow);
    XCloseDisplay(mydisplay);   
    return 0;
}

Когда окно становится видимым, сервер выдаст уведомление о событии экспозиции, если такой
тип события был установлен в структуре атрибутов окна. В программе на рисунке 2.8 это
выполняется с помощью оператора myat.event_mask = ExposureMask и включения myat во все
функции XCreateWindow() Xlib, используемые для создания четырех окон. Свойство X Window System заключается в том, что только после того, как сервер выдал первое событие экспозиции для программы X, может произойти любое
рисование на переднем плане любого окна этой программы. В большинстве программ X эта первая
экспозиция будет результатом родительского окна программы. В программе на рисунке 2.8 родительским
окном является mywindow. Как и во всех программах X, цикл событий управляет работой программы после инициализации
и создания окон и других ресурсов, таких как GC и т. д. В этом цикле программы на рисунке 2.8 была введена двухсекундная задержка системным вызовом sleep(), чтобы можно было наблюдать последовательность
изменений на экране. После возникновения первого события экспозиции передний план
окон win1 и win2 окрашивается в черный цвет с помощью функции Xlib XFillRectangle(). Когда
эти окна впервые появляются на экране, они окрашиваются в белый цвет (что не показано на рисунке 2.9.
Когда обрабатывается третье событие экспозиции, окно ontop отображается на экране, как показано на рисунке 2.9(b). При шестом событии экспозиции это последнее отображаемое окно (ontop) удаляется
с экрана. Эффект показан на рисунке 2.9(c). Наконец, нижнее окно (win2 удаляется с экрана с результатом, показанным на рисунке 2.9(d).

Хотя эта программа запросила сервер использовать сохранение под всеми окнами, это не было предоставлено. Рисунки 2.9(c) и (d) показывают, что этого не происходит. На этих рисунках белые области являются фоном окон win1 и win2. Эти части окна были перекрыты окном поверх
на рисунке 2.9(b). Удаление этого окна уничтожило часть переднего плана окон
покрытого. Фон этих окон стал видимым. Это далее показано на рисунке 2.9,
где окно win2 удалено, но фоновый узор в виде шахматной доски родительского окна не нарушен.
Если бы запрошенная служба сохранения под была доступна, то рисунок 2.9(c) был бы таким же, как (a). Белая часть на рисунке 2.9 была бы черной.
Принцип здесь заключается в том, что содержимое переднего плана окна теряется, когда этот передний план
накладывается другим окном. Содержимое фона окна не изменяется.
В программе на рисунке 2.8 события экспозиции учитывались только для выполнения различных операций
программы. Однако уведомления о событиях экспозиции содержат много информации о причине
события. Эта информация может быть использована для перерисовки всего или части окна, которое стало
открытым.

2.6.3 Упражнения
1. Реализуйте проверку на наличие ошибок в коде на рисунке 2.8.
2. Расширьте программу на рисунке 2.8, чтобы проверить, предоставляет ли используемый сервер все стандартные
серверные службы.
3. Выполните программу на рисунке 2.8 на сервере, на котором поддерживается сохранение, и обратите внимание на
разницу в поведении с тем, что изображено на рисунке 2.9.

4. Как можно отслеживать возникновение событий экспозиции (в качестве отладочной помощи) в программах,
таких как на рисунке 2.8?
5. Если содержимое переднего плана окна может быть потеряно из-за наложения, как можно защитить информацию,
отображаемую в окне, от возникновения таких событий?
6. Измените программу на рисунке 2.8 так, чтобы сервер находился по одному фиксированному адресу в сети, а клиент — по другому.
7. Используйте программу bitmap для создания двух дополнительных bitmap, затем измените программу
Рисунок 2.8 так, чтобы одно bitmap было наложено на фон окна win1, а другое на фон win2. Как это изменение влияет на отображение и отмену отображения этих соответствующих окон?
8. Перепишите программу Рисунок 2.8 в X Window toolkit по вашему выбору. Все facits программы должны быть реализованы. Какова разница в длине исходной и toolkit версий программы?
9. Измените программу Рисунок 2.8 так, чтобы окна win1, win2 и ontop накладывались друг на друга. Затем удалите каждое из этих окон в разных
разных порядках. Применяется ли то же самое удержание переднего плана/фона сервером во всех таких порядках удаления?
10. Перепишите код Рисунок 2.8 с использованием вызовов функций XSetWindowBackgroundPixmap() и XClearWindow()
Xlib. Какие преимущества дает такой подход (Подсказка: рассмотрите событие экспозиции, которое генерируется)? Где этот подход будет выгоден?
11. Реализуйте работу программы на рисунке 2.8, используя что-то иное, чем механизм событий, используемый в этой программе.
12. Используя рисунок 2.8 в качестве модели, напишите программу, которая генерирует 10 окон разного размера и
положения на экране, созданных алгоритмом по вашему выбору. Затем ваша программа должна отобразить
все эти окна на родительское окно, а затем удалить (отменить отображение) каждое окно в порядке, отличном от того, в котором они были отображены на экране.

